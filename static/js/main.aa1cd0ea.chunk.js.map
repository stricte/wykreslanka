{"version":3,"sources":["utils.js","App.js","reportWebVitals.js","index.js"],"names":["initGrid","m","n","Array","map","e","fill","dirs","right","down","rightdown","rightup","randomWord","words","sort","Math","random","slice","wordCords","startCords","direction","word","wordLen","length","cords","reduce","dir","moveCursor","currentCords","placeWordOnGrid","grid","forEach","index","value","charAt","updateGridAt","newGrid","cloneGrid","validateWordCords","i","cordsOutsideGrid","positionTaken","currentValue","valueAt","row","randomDir","keys","Object","floor","randomCords","min","max","fillGrid","j","String","fromCharCode","placedWords","JSON","parse","window","localStorage","getItem","placedWordsCords","wordsCount","wordsDict","includes","initialCords","push","generate","setItem","stringify","App","useState","start","setStart","stop","setStop","selectedCords","setSelectedCords","selectionMode","setSelectionMode","markedWords","setMarkedWords","markedCords","setMarkedCords","useEffect","wordMarkedIndex","useCallback","markedIndex","selectedKey","concat","join","placedWordCords","useLayoutEffect","x0","y0","x1","y1","dx","abs","sx","dy","sy","err","e2","lineCords","markedWordIndex","prev","cellMarked","find","className","cell","ii","classNames","selected","marked","onMouseDown","x","y","onMouseUp","onMouseOver","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"4PAmCMA,EAAW,SAACC,EAAGC,GACnB,OAAO,YAAIC,MAAMF,IAAIG,KAAI,SAACC,GAAD,OAAOF,MAAMD,GAAGI,KAAK,UAG1CC,EAAO,CACXC,MAAO,CAAC,EAAG,GAGXC,KAAM,CAAC,EAAG,GACVC,UAAW,CAAC,EAAG,GACfC,QAAS,EAAE,EAAG,IAKVC,EAAa,SAACC,GAAD,OACjBA,EAAMC,MAAK,kBAAMC,KAAKC,SAAWD,KAAKC,YAAUC,MAAM,EAAG,GAAG,IAExDC,EAAY,SAACC,EAAYC,EAAWC,GACxC,IAAMC,EAAUD,EAAKE,OACfC,EAAQ,CAACL,GAEf,OAAOhB,MAAMmB,EAAU,GACpBhB,KAAKc,GACLK,QACC,SAACD,EAAOE,GAAR,4BAAoBF,GAApB,CAA2BG,EAAWH,EAAMP,OAAO,GAAG,GAAIS,OAC1DF,IAIAG,EAAa,SAACC,EAAcR,GAChC,MAAO,CAACQ,EAAa,GAAKR,EAAU,GAAIQ,EAAa,GAAKR,EAAU,KAGhES,EAAkB,SAACR,EAAMH,EAAWY,GAMxC,OALAZ,EAAUa,SAAQ,SAACP,EAAOQ,GACxB,IAAMC,EAAQZ,EAAKa,OAAOF,GAC1BF,EAAOK,EAAaX,EAAOS,EAAOH,MAG7BA,GAGHK,EAAe,SAACX,EAAOS,EAAOH,GAClC,IAAMM,EAAUC,EAAUP,GAG1B,OAFAM,EAAQZ,EAAM,IAAIA,EAAM,IAAMS,EAEvBG,GAGHE,EAAoB,SAACjB,EAAMH,EAAWY,GAC1C,IAAK,IAAIS,EAAI,EAAGA,EAAIrB,EAAUK,OAAQgB,IAAK,CACzC,IAAMN,EAAQZ,EAAKa,OAAOK,GACpBf,EAAQN,EAAUqB,GAExB,GAAIC,EAAiBhB,EAAOM,GAAO,OAAO,EAC1C,GAAIW,EAAcjB,EAAOS,EAAOH,GAAO,OAAO,EAEhD,OAAO,GAGHU,EAAmB,SAAChB,EAAOM,GAC/B,OAAIN,EAAM,GAAK,GAAKA,EAAM,GAAKM,EAAKP,OAAS,IACzCC,EAAM,GAAK,GAAKA,EAAM,GAAKM,EAAK,GAAGP,OAAS,IAK5CkB,EAAgB,SAACjB,EAAOS,EAAOH,GACnC,IAAMY,EAAeC,EAAQnB,EAAOM,GACpC,QAASY,GAAgBA,IAAiBT,GAGtCU,EAAU,SAACnB,EAAOM,GACtB,OAAOA,EAAKN,EAAM,IAAIA,EAAM,KAGxBa,EAAY,SAACP,GACjB,OAAOA,EAAK1B,KAAI,SAACwC,GAAD,mBAAaA,OAGzBC,EAAY,SAACtC,GACjB,IAAMuC,EAAOC,OAAOD,KAAKvC,GAGzB,OAAOA,EAFKuC,EAAK/B,KAAKiC,MAAMjC,KAAKC,SAAW8B,EAAKvB,WAK7C0B,EAAc,SAAChD,EAAGC,GACtB,IAAMc,EAAS,SAACkC,EAAKC,GAAN,OAAcpC,KAAKiC,MAAMjC,KAAKC,UAAYmC,EAAMD,GAAOA,IAEtE,MAAO,CAAClC,EAAO,EAAGf,GAAIe,EAAO,EAAGd,KAM5BkD,EAAW,SAACtB,GAChBA,EAAOO,EAAUP,GAEjB,IAAK,IAAIS,EAAI,EAAGA,EAAIT,EAAKP,OAAQgB,IAC/B,IAAK,IAAIc,EAAI,EAAGA,EAAIvB,EAAK,GAAGP,OAAQ8B,IAC7BvB,EAAKS,GAAGc,KACXvB,EAAKS,GAAGc,GARdC,OAAOC,aAAa,GAAKxC,KAAKiC,MAAsB,GAAhBjC,KAAKC,YAazC,OAAOc,GCpIL0B,EAAcC,KAAKC,MAAMC,OAAOC,aAAaC,QAAQ,gBACrD/B,EAAO2B,KAAKC,MAAMC,OAAOC,aAAaC,QAAQ,SAC9CC,EAAmBL,KAAKC,MAC1BC,OAAOC,aAAaC,QAAQ,qBAG9B,IAAKC,IAAqBhC,IAASgC,EAAkB,CAAC,IAAD,EDiI7B,WAKtB,IAL2D,IAApC7D,EAAmC,uDAA/B,GAAIC,EAA2B,uDAAvB,GAAI6D,EAAmB,uDAAN,EAChDjC,EAAO9B,EAASC,EAAGC,GACnBsD,EAAc,GACdM,EAAmB,GAEhBN,EAAYjC,OAASwC,GAAY,CACtC,IAAM1C,EAAOT,EAAWoD,GAExB,IAAIR,EAAYS,SAAS5C,GAAzB,CAEA,IAAMD,EAAYyB,EAAUtC,GACtB2D,EAAejB,EAAYhD,EAAGC,GAE9BsB,EAAQN,EAAUgD,EAAc9C,EAAWC,GAE7CiB,EAAkBjB,EAAMG,EAAOM,KACjCA,EAAOD,EAAgBR,EAAMG,EAAOM,GAEpC0B,EAAYW,KAAK9C,GACjByC,EAAiBK,KAAK3C,KAM1B,MAAO,CAACgC,EAFR1B,EAAOsB,EAAStB,GAEWgC,GCzJaM,GADW,mBAClDZ,EADkD,KACrC1B,EADqC,KAC/BgC,EAD+B,KAGnDH,OAAOC,aAAaS,QAAQ,cAAeZ,KAAKa,UAAUd,IAC1DG,OAAOC,aAAaS,QAAQ,OAAQZ,KAAKa,UAAUxC,IACnD6B,OAAOC,aAAaS,QAClB,mBACAZ,KAAKa,UAAUR,IAmIJS,MA/Hf,WAAgB,IAAD,EACaC,qBADb,mBACNC,EADM,KACCC,EADD,OAEWF,qBAFX,mBAENG,EAFM,KAEAC,EAFA,OAI6BJ,qBAJ7B,mBAINK,EAJM,KAISC,EAJT,OAK6BN,oBAAS,GALtC,mBAKNO,EALM,KAKSC,EALT,OAOyBR,mBACpCf,KAAKC,MAAMC,OAAOC,aAAaC,QAAQ,gBAAkB,OAR9C,mBAONoB,EAPM,KAOOC,EAPP,OAUyBV,mBACpCf,KAAKC,MAAMC,OAAOC,aAAaC,QAAQ,gBAAkB,OAX9C,mBAUNsB,EAVM,KAUOC,EAVP,KAcbC,qBAAU,WACR1B,OAAOC,aAAaS,QAAQ,cAAeZ,KAAKa,UAAUW,IAC1DtB,OAAOC,aAAaS,QAAQ,cAAeZ,KAAKa,UAAUa,MACzD,CAACF,EAAaE,IAEjB,IAgBMG,EAAkBC,uBAAY,WAAO,IAAD,EACpCC,GAAe,EACbC,GAAc,MAAGC,OAAH,oBAAab,IAAec,KAAK,IAQrD,OANA7B,EAAiB/B,SAAQ,SAAC6D,EAAiB5D,GAAW,IAAD,GACjC,MAAG0D,OAAH,oBAAaE,IAAiBD,KAAK,MAEnCF,IAAaD,EAAcxD,MAGxCwD,IACN,CAACX,IAEJgB,2BAAgB,WACTpB,GACAE,GAELG,ED9EqB,SAACL,EAAOE,GAa/B,IAbyC,IAAD,cACzBF,EADyB,GACnCqB,EADmC,KAC/BC,EAD+B,mBAEzBpB,EAFyB,GAEnCqB,EAFmC,KAE/BC,EAF+B,KAIlCzE,EAAQ,GAER0E,EAAKnF,KAAKoF,IAAIH,EAAKF,GACvBM,EAAKN,EAAKE,EAAK,GAAK,EAChBK,EAAKtF,KAAKoF,IAAIF,EAAKF,GACvBO,EAAKP,EAAKE,EAAK,GAAK,EAElBM,GAAOL,EAAKG,EAAKH,GAAMG,GAAM,EAG/B7E,EAAM2C,KAAK,CAAC2B,EAAIC,IAEZD,IAAOE,GAAMD,IAAOE,GAHb,CAKX,IAAMO,EAAKD,EAEPC,GAAMN,IACRK,GAAOF,EACPP,GAAMM,GAEJI,EAAKH,IACPE,GAAOL,EACPH,GAAMO,GAIV,OAAO9E,ECgDYiF,CAAUhC,EAAOE,MACjC,CAACF,EAAOE,IAEXkB,2BAAgB,WACd,IAAId,GACCF,EAAL,CAEA,IAAM6B,EAAkBpB,IAEpBoB,GAAmB,IACrBxB,GAAe,SAACyB,GAAD,4BAAcA,GAAd,CAAoBD,OACnCtB,GAAe,SAACuB,GAAD,4BAAcA,GAAd,YAAuB9B,QAIxCC,IACAJ,IACAE,OACC,CAACG,EAAeF,EAAeS,IAElC,IAAMsB,EAAa,SAACpF,GAClB,QAAK2D,GAEEA,EAAY0B,MACjB,SAAC1B,GAAD,OACEA,EAAY,KAAO3D,EAAM,IAAM2D,EAAY,KAAO3D,EAAM,OAa9D,OACE,sBAAKsF,UAAU,YAAf,UACE,qBAAKA,UAAU,OAAf,SACGhF,EAAK1B,KAAI,SAACwC,EAAKL,GAAN,OACR,qBAAKuE,UAAU,MAAf,SACGlE,EAAIxC,KAAI,SAAC2G,EAAMC,GAAP,OACP,qBACEF,UAAWG,IAAW,OAAQ,CAC5BC,UAjBM1F,EAiBiB,CAACe,EAAGyE,KAhBpCnC,GAEEA,EAAcgC,MACnB,SAAChC,GAAD,OACEA,EAAc,KAAOrD,EAAM,IAAMqD,EAAc,KAAOrD,EAAM,OAalD2F,OAAQP,EAAW,CAACrE,EAAGyE,MAGzBI,YAAa,kBAnFNC,EAmFwB9E,EAnFrB+E,EAmFwBN,EAlF9ChC,GAAiB,GACjBN,EAAS,CAAC2C,EAAGC,SACb1C,EAAQ,CAACyC,EAAGC,IAHM,IAACD,EAAGC,GAoFVC,UAAW,kBA7EvB3C,EAAQ,CA6E+BrC,EAAGyE,SA5E1ChC,GAAiB,IA6ELwC,YAAa,kBA1ENH,EA0EwB9E,EA1ErB+E,EA0EwBN,OAzEzCjC,GACLH,EAAQ,CAACyC,EAAGC,KAFM,IAACD,EAAGC,GAkEZ,SAUGP,GAVH,eAKeC,IApBN,IAACxF,MAad,cAAiCe,SAmBrC,qBAAKuE,UAAU,WAAf,SACGtD,EAAYpD,KAAI,SAACiB,EAAMkB,GAAP,OACf,qBACEuE,UAAWG,IAAW,OAAQ,CAAEE,OAAQlC,EAAYhB,SAAS1B,KAD/D,SAIGlB,GAJH,eAEekB,aCrIVkF,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,K","file":"static/js/main.aa1cd0ea.chunk.js","sourcesContent":["import wordsDict from \"./words.json\";\n\nexport const lineCords = (start, stop) => {\n  let [x0, y0] = start;\n  let [x1, y1] = stop;\n\n  const cords = [];\n\n  const dx = Math.abs(x1 - x0),\n    sx = x0 < x1 ? 1 : -1;\n  const dy = Math.abs(y1 - y0),\n    sy = y0 < y1 ? 1 : -1;\n\n  let err = (dx > dy ? dx : -dy) / 2;\n\n  while (true) {\n    cords.push([x0, y0]);\n\n    if (x0 === x1 && y0 === y1) break;\n\n    const e2 = err;\n\n    if (e2 > -dx) {\n      err -= dy;\n      x0 += sx;\n    }\n    if (e2 < dy) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n\n  return cords;\n};\n\nconst initGrid = (m, n) => {\n  return [...Array(m)].map((e) => Array(n).fill(null));\n};\n\nconst dirs = {\n  right: [0, 1],\n  // left: [0, -1],\n  // up: [-1, 0],\n  down: [1, 0],\n  rightdown: [1, 1],\n  rightup: [-1, 1],\n  // leftdown: [1, -1],\n  // leftup: [-1, -1],\n};\n\nconst randomWord = (words) =>\n  words.sort(() => Math.random() - Math.random()).slice(0, 1)[0];\n\nconst wordCords = (startCords, direction, word) => {\n  const wordLen = word.length;\n  const cords = [startCords];\n\n  return Array(wordLen - 1)\n    .fill(direction)\n    .reduce(\n      (cords, dir) => [...cords, moveCursor(cords.slice(-1)[0], dir)],\n      cords\n    );\n};\n\nconst moveCursor = (currentCords, direction) => {\n  return [currentCords[0] + direction[0], currentCords[1] + direction[1]];\n};\n\nconst placeWordOnGrid = (word, wordCords, grid) => {\n  wordCords.forEach((cords, index) => {\n    const value = word.charAt(index);\n    grid = updateGridAt(cords, value, grid);\n  });\n\n  return grid;\n};\n\nconst updateGridAt = (cords, value, grid) => {\n  const newGrid = cloneGrid(grid);\n  newGrid[cords[0]][cords[1]] = value;\n\n  return newGrid;\n};\n\nconst validateWordCords = (word, wordCords, grid) => {\n  for (let i = 0; i < wordCords.length; i++) {\n    const value = word.charAt(i);\n    const cords = wordCords[i];\n\n    if (cordsOutsideGrid(cords, grid)) return false;\n    if (positionTaken(cords, value, grid)) return false;\n  }\n  return true;\n};\n\nconst cordsOutsideGrid = (cords, grid) => {\n  if (cords[0] < 0 || cords[0] > grid.length - 1) return true;\n  if (cords[1] < 0 || cords[1] > grid[0].length - 1) return true;\n\n  return false;\n};\n\nconst positionTaken = (cords, value, grid) => {\n  const currentValue = valueAt(cords, grid);\n  return !!currentValue && currentValue !== value;\n};\n\nconst valueAt = (cords, grid) => {\n  return grid[cords[0]][cords[1]];\n};\n\nconst cloneGrid = (grid) => {\n  return grid.map((row) => [...row]);\n};\n\nconst randomDir = (dirs) => {\n  const keys = Object.keys(dirs);\n  const key = keys[Math.floor(Math.random() * keys.length)];\n\n  return dirs[key];\n};\n\nconst randomCords = (m, n) => {\n  const random = (min, max) => Math.floor(Math.random() * (max - min) + min);\n\n  return [random(0, m), random(0, n)];\n};\n\nconst randomValue = () =>\n  String.fromCharCode(65 + Math.floor(Math.random() * 26));\n\nconst fillGrid = (grid) => {\n  grid = cloneGrid(grid);\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      if (!grid[i][j]) {\n        grid[i][j] = randomValue();\n      }\n    }\n  }\n\n  return grid;\n};\n\nexport const generate = (m = 10, n = 10, wordsCount = 7) => {\n  let grid = initGrid(m, n);\n  let placedWords = [];\n  let placedWordsCords = [];\n\n  while (placedWords.length < wordsCount) {\n    const word = randomWord(wordsDict);\n\n    if (placedWords.includes(word)) continue;\n\n    const direction = randomDir(dirs);\n    const initialCords = randomCords(m, n);\n\n    const cords = wordCords(initialCords, direction, word);\n\n    if (validateWordCords(word, cords, grid)) {\n      grid = placeWordOnGrid(word, cords, grid);\n\n      placedWords.push(word);\n      placedWordsCords.push(cords);\n    }\n  }\n\n  grid = fillGrid(grid);\n\n  return [placedWords, grid, placedWordsCords];\n};\n","import React, {\n  useState,\n  useLayoutEffect,\n  useCallback,\n  useEffect,\n} from \"react\";\nimport classNames from \"classnames\";\n\nimport \"./App.css\";\nimport { generate, lineCords } from \"./utils\";\n\nlet placedWords = JSON.parse(window.localStorage.getItem(\"placedWords\"));\nlet grid = JSON.parse(window.localStorage.getItem(\"grid\"));\nlet placedWordsCords = JSON.parse(\n  window.localStorage.getItem(\"placedWordsCords\")\n);\n\nif (!placedWordsCords || !grid || !placedWordsCords) {\n  [placedWords, grid, placedWordsCords] = generate();\n\n  window.localStorage.setItem(\"placedWords\", JSON.stringify(placedWords));\n  window.localStorage.setItem(\"grid\", JSON.stringify(grid));\n  window.localStorage.setItem(\n    \"placedWordsCords\",\n    JSON.stringify(placedWordsCords)\n  );\n}\n\nfunction App() {\n  const [start, setStart] = useState();\n  const [stop, setStop] = useState();\n\n  const [selectedCords, setSelectedCords] = useState();\n  const [selectionMode, setSelectionMode] = useState(false);\n\n  const [markedWords, setMarkedWords] = useState(\n    JSON.parse(window.localStorage.getItem(\"markedWords\") || \"[]\")\n  );\n  const [markedCords, setMarkedCords] = useState(\n    JSON.parse(window.localStorage.getItem(\"markedCords\") || \"[]\")\n  );\n\n  useEffect(() => {\n    window.localStorage.setItem(\"markedWords\", JSON.stringify(markedWords));\n    window.localStorage.setItem(\"markedCords\", JSON.stringify(markedCords));\n  }, [markedWords, markedCords]);\n\n  const onMouseDown = (x, y) => {\n    setSelectionMode(true);\n    setStart([x, y]);\n    setStop([x, y]);\n  };\n\n  const onMouseUp = (x, y) => {\n    setStop([x, y]);\n    setSelectionMode(false);\n  };\n\n  const onMouseOver = (x, y) => {\n    if (!selectionMode) return;\n    setStop([x, y]);\n  };\n\n  const wordMarkedIndex = useCallback(() => {\n    let markedIndex = -1;\n    const selectedKey = [].concat(...selectedCords).join(\"\");\n\n    placedWordsCords.forEach((placedWordCords, index) => {\n      const placedKey = [].concat(...placedWordCords).join(\"\");\n\n      if (placedKey === selectedKey) markedIndex = index;\n    });\n\n    return markedIndex;\n  }, [selectedCords]);\n\n  useLayoutEffect(() => {\n    if (!start) return;\n    if (!stop) return;\n\n    setSelectedCords(lineCords(start, stop));\n  }, [start, stop]);\n\n  useLayoutEffect(() => {\n    if (selectionMode) return;\n    if (!selectedCords) return;\n\n    const markedWordIndex = wordMarkedIndex();\n\n    if (markedWordIndex > -1) {\n      setMarkedWords((prev) => [...prev, markedWordIndex]);\n      setMarkedCords((prev) => [...prev, ...selectedCords]);\n    } else {\n    }\n\n    setSelectedCords();\n    setStart();\n    setStop();\n  }, [selectionMode, selectedCords, wordMarkedIndex]);\n\n  const cellMarked = (cords) => {\n    if (!markedCords) return false;\n\n    return markedCords.find(\n      (markedCords) =>\n        markedCords[0] === cords[0] && markedCords[1] === cords[1]\n    );\n  };\n\n  const cellSelected = (cords) => {\n    if (!selectedCords) return false;\n\n    return selectedCords.find(\n      (selectedCords) =>\n        selectedCords[0] === cords[0] && selectedCords[1] === cords[1]\n    );\n  };\n\n  return (\n    <div className=\"container\">\n      <div className=\"grid\">\n        {grid.map((row, i) => (\n          <div className=\"row\" key={`row-${i}`}>\n            {row.map((cell, ii) => (\n              <div\n                className={classNames(\"cell\", {\n                  selected: cellSelected([i, ii]),\n                  marked: cellMarked([i, ii]),\n                })}\n                key={`cell-${ii}`}\n                onMouseDown={() => onMouseDown(i, ii)}\n                onMouseUp={() => onMouseUp(i, ii)}\n                onMouseOver={() => onMouseOver(i, ii)}\n              >\n                {cell}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n\n      <div className=\"wordList\">\n        {placedWords.map((word, i) => (\n          <div\n            className={classNames(\"word\", { marked: markedWords.includes(i) })}\n            key={`word-${i}`}\n          >\n            {word}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}